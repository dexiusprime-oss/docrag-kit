"""Command-line interface for DocRAG Kit."""

import click
from pathlib import Path
from docrag import __version__


def create_mcp_server_wrapper(docrag_dir: Path) -> bool:
    """
    Create mcp_server.py wrapper in .docrag directory.
    
    Args:
        docrag_dir: Path to .docrag directory
        
    Returns:
        True if successful, False otherwise
    """
    mcp_server_content = '''#!/usr/bin/env python3
"""
MCP Server wrapper for this project.

This file is auto-generated by DocRAG Kit.
It provides a simple entry point for the MCP server.

Usage:
    python mcp_server.py
    
Or configure in Kiro AI's MCP settings.
"""

import asyncio
import sys
from pathlib import Path

# Add parent directory to path to import docrag
sys.path.insert(0, str(Path(__file__).parent.parent))

from docrag.mcp_server import MCPServer


async def main():
    """Run MCP server for this project."""
    try:
        # Initialize server with current directory
        server = MCPServer(config_path=Path(__file__).parent)
        await server.run()
    except Exception as e:
        print(f"‚ùå Failed to start MCP server: {e}", file=sys.stderr)
        sys.exit(1)


if __name__ == "__main__":
    asyncio.run(main())
'''
    
    try:
        mcp_server_path = docrag_dir / "mcp_server.py"
        mcp_server_path.write_text(mcp_server_content)
        mcp_server_path.chmod(0o755)  # Make executable
        return True
    except Exception:
        return False


@click.group()
@click.version_option(version=__version__, prog_name="docrag")
def cli():
    """DocRAG Kit - Universal RAG system for project documentation.
    
    Quick start:
    1. Run 'docrag init' to initialize RAG system in your project
    2. Run 'docrag index' to index your documentation
    3. Run 'docrag mcp-config' to get MCP server configuration
    """
    pass


@cli.command()
@click.option("--non-interactive", is_flag=True, help="Use default values without prompts")
@click.option("--template", type=click.Choice(['general', 'symfony', 'ios']), default='general', help="Project template to use")
def init(non_interactive, template):
    """Initialize DocRAG in current project."""
    from pathlib import Path
    from .config_manager import ConfigManager
    
    # Check if .docrag/ already exists
    docrag_dir = Path.cwd() / ".docrag"
    if docrag_dir.exists():
        click.echo("‚ùå Error: .docrag/ directory already exists")
        click.echo("   DocRAG is already initialized in this project")
        click.echo("   Use 'docrag config --edit' to modify configuration")
        return
    
    try:
        # Run setup wizard (interactive or non-interactive)
        config_manager = ConfigManager()
        if non_interactive:
            # Use default configuration based on template
            from .config_manager import DocRAGConfig
            config = DocRAGConfig.from_template(template)
            click.echo(f"‚úÖ Using {template} template with default values")
        else:
            config = config_manager.interactive_setup()
        
        # Create .docrag/ directory
        docrag_dir.mkdir(parents=True, exist_ok=True)
        
        # Save configuration to config.yaml
        config_manager.save_config(config)
        click.echo(f"\n‚úÖ Configuration saved to {config_manager.config_path}")
        
        # Create .docrag/.gitignore
        from .security import (
            create_docrag_gitignore, 
            display_gitignore_warning,
            create_env_example,
            display_security_reminder
        )
        
        if create_docrag_gitignore(docrag_dir):
            click.echo(f"‚úÖ Created {docrag_dir / '.gitignore'}")
        else:
            click.echo(f"‚ö†Ô∏è  Failed to create {docrag_dir / '.gitignore'}")
        
        # Create .env.example template
        if create_env_example(Path.cwd()):
            click.echo(f"‚úÖ Created .env.example template")
        else:
            click.echo(f"‚ö†Ô∏è  Failed to create .env.example")
        
        # Create mcp_server.py wrapper
        if create_mcp_server_wrapper(docrag_dir):
            click.echo(f"‚úÖ Created {docrag_dir / 'mcp_server.py'}")
        else:
            click.echo(f"‚ö†Ô∏è  Failed to create {docrag_dir / 'mcp_server.py'}")
        
        # Check root .gitignore and warn if .env is not excluded
        display_gitignore_warning(Path.cwd(), offer_fix=True)
        
        # Display security reminder
        display_security_reminder()
        
        # Display next steps
        click.echo("\nüìù Next steps:")
        click.echo("   1. Run: docrag index")
        click.echo("   2. Run: docrag mcp-config")
        click.echo("\n   Documentation: https://github.com/docrag-kit/docrag-kit")
        
    except KeyboardInterrupt:
        click.echo("\n\n‚ùå Setup cancelled")
        return
    except Exception as e:
        click.echo(f"\n‚ùå Error during initialization: {e}")
        return


@cli.command()
@click.option("--force", is_flag=True, help="Overwrite existing database without confirmation")
def index(force):
    """Index project documents."""
    from pathlib import Path
    from .config_manager import ConfigManager
    from .document_processor import DocumentProcessor
    from .vector_db import VectorDBManager
    
    project_root = Path.cwd()
    
    # Load configuration
    config_manager = ConfigManager(project_root)
    config = config_manager.load_config()
    
    if config is None:
        click.echo("‚ùå Error: Configuration not found")
        click.echo("   Run 'docrag init' to initialize DocRAG first")
        return
    
    # Convert config to dictionary for processors
    config_dict = config.to_dict()
    
    try:
        # Check for API key
        vector_db = VectorDBManager(config_dict, project_root)
        
        # Check if database already exists
        db_path = project_root / ".docrag" / "vectordb"
        if db_path.exists():
            click.echo("‚ö†Ô∏è  Vector database already exists")
            if not force and not click.confirm("   Overwrite existing database?", default=False):
                click.echo("‚ùå Indexing cancelled")
                return
        
        # Scan and load documents
        click.echo("\nüìÅ Scanning documents...")
        doc_processor = DocumentProcessor(config_dict)
        chunks, stats = doc_processor.process(project_root)
        
        if stats['files_found'] == 0:
            click.echo("‚ùå No files found to index")
            click.echo("   Check your configuration:")
            click.echo(f"   - Directories: {config.indexing.directories}")
            click.echo(f"   - Extensions: {config.indexing.extensions}")
            return
        
        # Display file count
        click.echo(f"‚úÖ Found {stats['files_found']} files to index")
        
        if stats['files_processed'] < stats['files_found']:
            click.echo(f"‚ö†Ô∏è  {stats['files_found'] - stats['files_processed']} files failed to load")
        
        # Create vector database
        click.echo(f"\nüìä Creating vector database...")
        click.echo(f"   Processing {stats['chunks_created']} chunks...")
        
        vector_db.create_database(chunks, show_progress=True)
        
        # Display statistics
        click.echo("\n‚úÖ Indexing complete!")
        click.echo(f"   Files processed: {stats['files_processed']}")
        click.echo(f"   Chunks created: {stats['chunks_created']}")
        click.echo(f"   Total characters: {stats['total_characters']:,}")
        
        # Display next steps
        click.echo("\nüìù Next steps:")
        click.echo("   Run: docrag mcp-config")
        
    except ValueError as e:
        click.echo(f"\n{e}")
        return
    except Exception as e:
        click.echo(f"\n‚ùå Error during indexing: {e}")
        import traceback
        traceback.print_exc()
        return


@cli.command()
@click.option("--force", is_flag=True, help="Skip confirmation prompt")
def reindex(force):
    """Rebuild vector database from scratch."""
    from pathlib import Path
    from .config_manager import ConfigManager
    from .document_processor import DocumentProcessor
    from .vector_db import VectorDBManager
    
    project_root = Path.cwd()
    
    # Load configuration
    config_manager = ConfigManager(project_root)
    config = config_manager.load_config()
    
    if config is None:
        click.echo("‚ùå Error: Configuration not found")
        click.echo("   Run 'docrag init' to initialize DocRAG first")
        return
    
    # Convert config to dictionary for processors
    config_dict = config.to_dict()
    
    # Display warning
    click.echo("‚ö†Ô∏è  WARNING: This will delete the existing vector database")
    click.echo("   All indexed data will be removed and rebuilt from scratch")
    
    # Ask for confirmation
    if not force and not click.confirm("\n   Continue with reindexing?", default=False):
        click.echo("‚ùå Reindexing cancelled")
        return
    
    try:
        # Initialize vector database manager
        vector_db = VectorDBManager(config_dict, project_root)
        
        # Delete old database
        click.echo("\nüóëÔ∏è  Deleting old database...")
        vector_db.delete_database()
        click.echo("‚úÖ Old database deleted")
        
        # Scan and load documents
        click.echo("\nüìÅ Scanning documents...")
        doc_processor = DocumentProcessor(config_dict)
        chunks, stats = doc_processor.process(project_root)
        
        if stats['files_found'] == 0:
            click.echo("‚ùå No files found to index")
            click.echo("   Check your configuration:")
            click.echo(f"   - Directories: {config.indexing.directories}")
            click.echo(f"   - Extensions: {config.indexing.extensions}")
            return
        
        # Display file count
        click.echo(f"‚úÖ Found {stats['files_found']} files to index")
        
        if stats['files_processed'] < stats['files_found']:
            click.echo(f"‚ö†Ô∏è  {stats['files_found'] - stats['files_processed']} files failed to load")
        
        # Create vector database
        click.echo(f"\nüìä Creating vector database...")
        click.echo(f"   Processing {stats['chunks_created']} chunks...")
        
        vector_db.create_database(chunks, show_progress=True)
        
        # Display updated statistics
        click.echo("\n‚úÖ Reindexing complete!")
        click.echo(f"   Files processed: {stats['files_processed']}")
        click.echo(f"   Chunks created: {stats['chunks_created']}")
        click.echo(f"   Total characters: {stats['total_characters']:,}")
        
    except ValueError as e:
        click.echo(f"\n{e}")
        return
    except Exception as e:
        click.echo(f"\n‚ùå Error during reindexing: {e}")
        import traceback
        traceback.print_exc()
        return


@cli.command()
@click.option("--edit", is_flag=True, help="Open configuration in editor")
def config(edit):
    """Display or edit current configuration."""
    from pathlib import Path
    import subprocess
    import os
    import yaml
    from .config_manager import ConfigManager
    
    project_root = Path.cwd()
    config_manager = ConfigManager(project_root)
    
    # Check if configuration exists
    if not config_manager.config_path.exists():
        click.echo("‚ùå Error: Configuration not found")
        click.echo("   Run 'docrag init' to initialize DocRAG first")
        return
    
    if edit:
        # Open configuration in editor
        click.echo("‚úèÔ∏è  Opening configuration in editor...")
        
        # Determine editor (use EDITOR env var or default to system editor)
        editor = os.environ.get('EDITOR')
        
        if not editor:
            # Try common editors
            if os.system('which code > /dev/null 2>&1') == 0:
                editor = 'code'
            elif os.system('which nano > /dev/null 2>&1') == 0:
                editor = 'nano'
            elif os.system('which vim > /dev/null 2>&1') == 0:
                editor = 'vim'
            elif os.system('which vi > /dev/null 2>&1') == 0:
                editor = 'vi'
            else:
                # Fallback to open (macOS) or xdg-open (Linux)
                import platform
                if platform.system() == 'Darwin':
                    editor = 'open'
                else:
                    editor = 'xdg-open'
        
        try:
            subprocess.run([editor, str(config_manager.config_path)])
            click.echo("‚úÖ Configuration file opened")
        except Exception as e:
            click.echo(f"‚ùå Error opening editor: {e}")
            click.echo(f"   Try manually editing: {config_manager.config_path}")
    
    else:
        # Display current configuration
        click.echo("‚öôÔ∏è  Current configuration:\n")
        
        try:
            # Load and display YAML
            with open(config_manager.config_path, 'r', encoding='utf-8') as f:
                config_data = yaml.safe_load(f)
            
            # Pretty print the configuration
            click.echo(yaml.dump(config_data, default_flow_style=False, sort_keys=False))
            
            click.echo(f"\nüìÅ Configuration file: {config_manager.config_path}")
            click.echo("   Use 'docrag config --edit' to modify")
        
        except Exception as e:
            click.echo(f"‚ùå Error reading configuration: {e}")


@cli.command("mcp-config")
def mcp_config():
    """Display MCP server configuration for Kiro."""
    from pathlib import Path
    import json
    import platform
    from .config_manager import ConfigManager
    
    project_root = Path.cwd()
    config_manager = ConfigManager(project_root)
    
    # Check if configuration exists
    if not config_manager.config_path.exists():
        click.echo("‚ùå Error: Configuration not found")
        click.echo("   Run 'docrag init' to initialize DocRAG first")
        return
    
    # Load configuration to get project name
    config = config_manager.load_config()
    if config is None:
        click.echo("‚ùå Error: Failed to load configuration")
        return
    
    project_name = config.project.name
    
    # Get absolute path to mcp_server.py
    mcp_server_path = project_root / ".docrag" / "mcp_server.py"
    
    # Check if mcp_server.py exists
    if not mcp_server_path.exists():
        click.echo("‚ö†Ô∏è  Warning: mcp_server.py not found")
        click.echo(f"   Expected at: {mcp_server_path}")
        click.echo("   This file should be created during 'docrag init'")
        return
    
    # Generate MCP server configuration
    # Use simple name like other MCP servers (context7, perplexity, etc.)
    server_name = "docrag"
    
    # Detect Python executable with MCP library installed
    import sys
    import subprocess
    
    def find_python_with_mcp():
        """Find Python executable that has mcp library installed."""
        # Try current Python first
        candidates = [sys.executable]
        
        # Add common pyenv Python 3.10+ locations
        pyenv_root = Path.home() / ".pyenv" / "versions"
        if pyenv_root.exists():
            for version_dir in sorted(pyenv_root.iterdir(), reverse=True):
                if version_dir.is_dir() and version_dir.name.startswith("3.1"):
                    python_bin = version_dir / "bin" / "python"
                    if python_bin.exists():
                        candidates.append(str(python_bin))
        
        # Test each candidate
        for python_path in candidates:
            try:
                result = subprocess.run(
                    [python_path, "-c", "import mcp; import docrag"],
                    capture_output=True,
                    timeout=5
                )
                if result.returncode == 0:
                    return python_path
            except:
                continue
        
        # Fallback to current Python
        return sys.executable
    
    python_executable = find_python_with_mcp()
    
    mcp_config = {
        "mcpServers": {
            server_name: {
                "command": python_executable,
                "args": [str(mcp_server_path)],
                "env": {},
                "disabled": False,
                "autoApprove": []
            }
        }
    }
    
    # Display configuration
    click.echo("üîå MCP Server Configuration for Kiro\n")
    click.echo("Add this to your Kiro MCP configuration file:")
    click.echo(".kiro/settings/mcp.json (workspace config)\n")
    
    click.echo("```json")
    click.echo(json.dumps(mcp_config, indent=2))
    click.echo("```\n")
    
    # Display manual instructions
    click.echo("üìù Manual Setup Instructions:")
    click.echo("1. Open or create: .kiro/settings/mcp.json")
    click.echo("2. Add the above configuration to the 'mcpServers' section")
    click.echo("3. Restart Kiro or reload MCP servers")
    click.echo("4. The server will appear as: " + server_name)
    
    # Try to add to workspace config automatically
    workspace_config_path = project_root / ".kiro" / "settings" / "mcp.json"
    
    click.echo("\nüéØ Adding to workspace configuration...")
    
    if click.confirm("   Would you like to automatically add this configuration?", default=True):
        try:
            # Read existing config or create new one
            if workspace_config_path.exists():
                # Backup existing config
                backup_path = workspace_config_path.with_suffix('.json.backup')
                import shutil
                shutil.copy2(workspace_config_path, backup_path)
                click.echo(f"   ‚úÖ Backed up existing config to {backup_path}")
                
                # Load existing config
                with open(workspace_config_path, 'r', encoding='utf-8') as f:
                    existing_config = json.load(f)
            else:
                existing_config = {"mcpServers": {}}
            
            # Ensure mcpServers exists
            if "mcpServers" not in existing_config:
                existing_config["mcpServers"] = {}
            
            # Add new server entry
            existing_config["mcpServers"][server_name] = mcp_config["mcpServers"][server_name]
            
            # Ensure directory exists
            workspace_config_path.parent.mkdir(parents=True, exist_ok=True)
            
            # Write updated config
            with open(workspace_config_path, 'w', encoding='utf-8') as f:
                json.dump(existing_config, f, indent=2)
            
            click.echo(f"   ‚úÖ Configuration added to {workspace_config_path}")
            click.echo("   üîÑ Restart Kiro or reload MCP servers to activate")
            
            # Add note about user config option
            click.echo("\nüí° Note: Configuration added to workspace config (.kiro/settings/mcp.json)")
            click.echo("   This makes the MCP server available only in this workspace")
            click.echo("   To make it available globally, add to: ~/.kiro/settings/mcp.json")
        
        except Exception as e:
            click.echo(f"   ‚ùå Error adding configuration: {e}")
            click.echo("   Please add the configuration manually")
    else:
        click.echo("\nüí° Tip: You can manually add the configuration to:")
        click.echo("   - Workspace: .kiro/settings/mcp.json (recommended)")
        click.echo("   - User: ~/.kiro/settings/mcp.json (global)")


if __name__ == "__main__":
    cli()
